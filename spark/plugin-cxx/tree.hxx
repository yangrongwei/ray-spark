/*
 * cxx-tree.hxx
 *
 *  Mapping various GENERIC 'tree node' to C++ class.
 *
 *  Created on: Mar 14, 2012
 *      Author: ray
 */

#ifndef CXX_TREE_HXX_
#define CXX_TREE_HXX_

//Ray:
//
// I guess, this file can be generated by code, at least with its help.
// But, I do not know how to do it, we map them by hand now...
// Maybe someday later, this file is generated...


// The object-in-C style of [plug-inc]/tree.h is

// The purpose of this file (cxx-tree.hxx) is to wrap these macros into
// C++ member functions. As a result, it will give programmer visual
// shows which exactly the macro is doing from function prototype.
// And give programmer a true object feeling to access various 'tree node'.
//
// Keep in mind, no more, may less...
//

// Hints to map marcro to member function
//
// TODO: copy/translate notes from my SkyDrive into here
//  Two key hints:
//  1. xxx_CHECK   xxx_CST_CHECK
//  2. (NODE)->xxx.foo
// For example
//
// virtual ??
// It seems for each type/class xxx_CHECK, we should have a corresponding C++ class
//

// 交叉参考约定 Code Reference Comment Convention
// This comment points out the original source code position in gcc 4.6.1
//
// -- [dir-prefix] filename : linenumber
//
//
// 1. When no dir-prefix is given, default directory prefix is [plug-inc]
//   （此约定去除。N 久以后，我自己看不懂了。默认约定总是太过神奇）
//    哦... 不，没有此约定，实在太啰嗦了，
//
// 2. When refer to gcc source, we should alway use [gcc-src] prefix
// 3. 定义的前缀       Valid dir-prefix are:
//    （当年怎么会用  [ ] 的呢……，现在干嘛用 < >  这个常见约定吧？）
//
//    <gcc-4.6.1>
//
//    [plug-inc]     plugin include directory for plugin deverlopers
//    [gcc-src]      gcc source code root directory
//    /              source root directory for this project
//
// For example:
// -- tree.h:367                      example 1
// -- [plug-inc]/tree.h:367           example 2
// -- [gcc-src]/gcc/tree.c:8624       example 3
// -- /doc/bitfield-in-enum.txt
//
//    'example 1' and 'example 2' are equivalent
// （行号分割用 : 号似乎当时也是选的，用 # 号，实在太碍眼了，一眼看不清数字， # 这小子太高了，五大三粗的）
//
// Informal extended example:
//
// M_ tree TypeCanonical(void);    // -- tree.h:2113, M_2374
//  Macro to member function map
//  1. The macro is defined     in [plug-inc]/tree.h line 2113
//  2. The return type is found in [plug-inc]/tree.h line 2374, which is describing a type specific member
//  -. All setter return the setting value, not 'void'.
//     Why? It will keep same effect as macro does. And maybe who needs it.
//     Cost? Negligible comparing with benefits.
//
// Macro purpose marker list:
//  M_      (type specific) Member variable getter macro
//  Ms_     (type specific) Member variable Setter macro
//  P_      Property (value is caculated on-the-foly) getter
//  Ps_     Property Setter
//
//  Pc_   == C_ ??
//  C_      aggregation (container) helper ?? accessor ??
//          // Why not Container ?  Easy to confusing with class,
//          // Somewhat borrowed from UML
//

// Abbriviation list (sadly, used in intuitive name)
//   I want to use full name whenever possible in my coined intuitive name.
//   But, sometimes, the name is too long to read at a glance, which make it be not intuitive.
//   So we have this list. Key consitent express or use them sometime???
// identifier   ident
// pointer      ptr

// strange gcc-macro conversion founds:
// 1. For c-string, the macro uses the name xxx_POINTER (strange, why? like shit)

// Identfiy it is the top/root class in a class hierarchy
// Is handy attribute exist ?
#define ROOT_CLASS

#define LEAF_CLASS
#define MIDDLE_CLASS


// to mark bit-field ??  n1548-c-standard-sec-6.7.2.1-para-9
// 1 bit wide flag bit-field is mapped directly to C++ bool type, type safe purpse...
#define Bf(width, type)   type      //bit-field, use less bits in corresponding integer type
#define Bf_enum(width, enum_name, int_name) int_name

	// TODO:
	// We need a strong-typed enum, not gcc's C enum in this header file, of course C++11's enum class
	// This means we MUST copy the enum from gcc code, dirty, but it will give us type safe benefit..
//	/*virtual */ M_ enum class machine_mode TypeMode(void);

#define Enum(enum_name)  int  //avoid include enum definition
//#define Enum(enum_name)  enum enum_name
//#define Enum(enum_name)  enum class enum_name

// For VEC(T, A) * -- vec.h:509
#define Vec_ptr(elemet_type, vec_alloc_strategy) void *

#define c_virtual   // virtual candidate for C++

#include <stddef.h>

// Copied from [plug-inc]/coretypes.h to avoid include the file.
// Consequently, any file includes this file will not depend on GCC directly.
//
union tree_node;                            // -- coretypes.h:59   defined in -- gcc-4_6_1-release/gcc/tree.h#3510
typedef union tree_node *tree;              // -- coretypes.h:96
typedef const union tree_node *const_tree;  // -- coretypes.h:63


namespace plugin_cxx
{
//Ray:
// A helper class to manipulate 'enum tree_code'
//
// object-in-c type system support helper
//
// Generic type classifying service
// -- tree.h:42
//enum tree_code {
//#include "all-tree.def"
//MAX_TREE_CODES
//};
class _tree_code_helper
{
	// refer to tree.h:368 code is 16-bits limited
	//Bf(16) const int m_code; //Discard 'enum tree_code' type info intentionally in header

	tree m_node;
	tree GetTreeNode();
public:
	explicit _tree_code_helper(tree node):m_node(node){}
public:

public:
	//Ray:
	// This work is better to delegate to _tree_code_helper
	// But the macros use TREE_CODE() .... which requires a tree_base
	// So they are here...

//	// -- plugin/include/tree.h:1021
//	//...
//	// -- plugin/include/tree.h:1091
//	bool CompleteTypeP();
//	// -- plugin/include/tree.h:1094
//	bool VoidTypeP();

	//Ray: Following predication use both 'enum tree_code' and flags defined in 'tree_base'
	//     It's better to put them in 'tree_base', but it will bloat the class too large...
	//     Put here is clear, their purpose is used in object-in-c type system
	bool ExprP();                 // -- tree.h:171
	bool IntegralTypeP();         // -- tree.h:1021 P_368
	bool NonSatFixedPointTypeP(); // -- tree.h:1028 P_(368, 386)
	bool SatFixedPointTypeP();    // -- tree.h:1033 P_(368, 386)
	bool FixedPointTypeP();       // -- tree.h:1038 P_368
	bool ScalarFloatTypeP();      // -- tree.h:1042 P_368
	bool ComplexFloatTypeP();     // -- tree.h:1046 P_(368, 413) // tree_common
	bool VectorFloatTypeP();      // -- tree.h:1052 P_(368, 413) // tree_common
	bool FloatTypeP();            // -- tree.h:1060 P_(368, 413) // tree_common
	bool DecimalFloatTypeP();     // -- tree.h:1067 P_(368, 2347, --machmode.h:85) // tree_type
	bool RecordOrUnionTypeP();    // -- tree.h:1072 P_368
	bool AggregateTypeP();        // -- tree.h:1080 P_368
	bool PointerTypeP();          // -- tree.h:1087 P_368
	bool CompleteTypeP();         // -- tree.h:1091 P_(2064, 2335) // tree_type
	bool VoidTypeP();             // -- tree.h:1094 P_368
	bool CompleteOrVoidTypeP();   // -- tree.h:1097 P_(1091, 1094) // tree_type
	bool CompleteOrUnboundArrayTypeP(); // -- tree.h:1101 P_1091   // tree_type
public:
	// -- tree.h:661-941
	// Various TREE_CHECK macro is not mapped here.
	// They are implementation detail, for coding support.
//	//Ray:
//	// TREE_CHECK() macro            -- tree.h:(663, 917)
//	// tree_check_failed() function  -- [gcc-src]/gcc/tree.c:8624
//	// internal_error() function     -- [gcc-src]/gcc/diagnostic.c:832
//	bool Try_TREE_CHECK();

	// -- tree.h:947
	// tree code class check ??
	// It seems implementation detai, for coding support.

	// Ray:
	// It seems we do not need mapping xxx_CHECK macros here
	// They will be used in corresponding class constructor, looks like.

};

// -- tree.h:347
/* A tree node can represent a data type, a variable, an expression
   or a statement.  Each node has a TREE_CODE which says what kind of
   thing it represents.  Some common codes are:
   INTEGER_TYPE -- represents a type of integers.
   ARRAY_TYPE -- represents a type of pointer.
   VAR_DECL -- represents a declared variable.
   INTEGER_CST -- represents a constant integer value.
   PLUS_EXPR -- represents a sum (an expression).

   As for the contents of a tree node: there are some fields
   that all nodes share.  Each TREE_CODE has various special-purpose
   fields as well.  The fields of a node are never accessed directly,
   always through accessor macros.  */

/* Every kind of tree node starts with this structure,
   so all nodes have these fields.

   See the accessor macros, defined below, for documentation of the
   fields.  */
//
//Ray: It is a base class, which provids lots service, it's large, as expected.
// 'tree_code' is used to distinguish various types.
// The heart of gcc's object-in-c way, its own type system.
// TODO: a brief comments for struct tree_base
// 1. tree_code for custom type system  -- tree.h:368
// 2. various flags                     -- tree.h:370-400
// 3. two other fields, one for flag padding, one for saving space
//    --total bit count of flags ??? caculate it by our demo code

// Tree node class family hierachy map
// struct name                    | defining position | printable name in streestruct.def
// -------------------------------|-------------------|----------------------------------
// tree_base                        -- tree.h:367      "base"--treestruct.def:33
// +-tree_common                    -- tree.h:410      "common"--treestruct.def:34
//   +-tree_int_cst                 -- tree.h:1409     "integer cst"--treestruct.def:35
//   +-tree_real_cst                -- tree.h:1422     "real cst"--36
//   +-tree_fixed_cst               -- tree.h:1434     "fixed cst"--37
//   +-tree_string                  -- tree.h:1444
//   +-tree_complex                 -- tree.h:1454
//   +-tree_vector                  -- tree.h:1463     "vector"--38
//   +-tree_identifier              -- tree.h:1486
//   +-tree_list                    -- tree.h:1495
//   +-tree_vec                     -- tree.h:1508
//   +-tree_constructor             -- tree.h:1567     "constructor"--64
//   +-tree_exp                     -- tree.h:1857     "exp"--59
//     +-//lots subclass defined in tree.def with _EXPR postfix
//   +-tree_ssa_name                -- tree.h:1923     "ssa name"--60
//   +-tree_omp_clause              -- tree.h:1963     "omp clause"--65
//   +-tree_block                   -- tree.h:2034
//   +-tree_type                    -- tree.h:2332
//   +-tree_binfo                   -- tree.h:2482
//   +-tree_decl_minimal            -- tree.h:2579     "decl minimal"--42
//   | +-tree_decl_common           -- tree.h:2747
//   | | +-tree_decl_with_rtl       -- tree.h:2863
//   | |   +-tree_label_decl        -- tree.h:2954
//   | |   +-tree_result_decl       -- tree.h:2964
//   | |   +-tree_const_decl        -- tree.h:2969
//   | |   +-tree_parm_decl         -- tree.h:2982
//   | |   +-tree_decl_with_vis     -- tree.h:3121     "decl with visibility"--46
//   | |     +-tree_var_decl        -- tree.h:3205
//   | |     +-tree_decl_non_common -- tree.h:3227
//   | |       +-tree_function_decl -- tree.h:3369
//   | |       +-tree_type_decl     -- tree.h:3443
//   | +-tree_field_decl            -- tree.h:2931
//   | +-tree_translation_unit_decl -- tree.h:3417
//   +-tree_statement_list          -- tree.h:3466
//   +-tree_optimization_option     -- tree.h:3476
//   +-tree_target_option           -- tree.h:3491
// .
// .
// tree_node						-- tree.h:3510
//
// tree_base  						-- gcc-4_6_1-release/gcc/tree.h#L367
//
//

//Ray: For checking, refer to [gcc-src]/gcc/tree.c:350

// -- plugin/include/tree.h:367
//struct GTY(()) tree_base {
//  ENUM_BITFIELD(tree_code) code : 16;
//
//  unsigned side_effects_flag : 1;
//  unsigned constant_flag : 1;
//  unsigned addressable_flag : 1;
//  //...
class ROOT_CLASS tree_base {
protected:
	tree m_node;
	//tree_base(const tree& node) = delete;  // Why cannot explicitly delete it???
	tree_base& operator = (const tree& node) = delete;
public:
	explicit tree_base(tree node):m_node(node){};

public: // Direct macro to member function map
  //refer to --/doc/bitfield-in-enum.txt
  // Type safe is not very useful here, we should use them rarely. Just int, simple.
	//Ray: We should use following two memeber functions ONLY for communicating with
	//     legacy gcc-object-in-c system. Not in our own C++ class hierachy system.
	Bf_enum(16, tree_code, unsigned int) TreeCode() const;           // -- tree.h:656, M_368  //To more generic type, right?
	Bf_enum(16, tree_code, unsigned int) TreeSetCode( Bf_enum(16, tree_code, unsigned int) );  // -- tree.h:657, Ms_368 //Ray: good or bad? enum can be auto converted
	size_t TreeHash() const;                        // -- tree.h:974, P_ based-on m_node value

	// skip from 977, later check it

	//Ray: not in this class, and wrong, to put to where ??
//	// -- plugin/include/tree.h:993
//	tree StripNops(const_tree);       // -- tree.h:993
//	tree StripSignNops(const_tree);   // -- tree.h:998
//	tree StripTypeNops(tree);   // -- tree.h:1003
//	tree StripUselessTypeConversion(tree);  // -- tree.h:1014

public: // prediate mapping -- macro --> member function
	// to void bloat this class
	// xxx_P are delegate to _tree_code_helper
	//
public: // xxx_CHECK macros
	// delegate to _tree_code_helper too?
	// or not appear in class interface at all?


public: // flag-mapping  -- Direct macro to member function map // member access
  //Ray:
  // flag purpose can be found in
  // 1. [plug-in]/tree.h:416-614   A big flag check list for various nodes
  // 2. macro's comment -- tree.h:1107-???        seperated in various location in tree.h
  // 3. the flag name defined in struct tree_base
  // ...
  // Ray: We have opportunity to direct describe various purpose
  //      in subclassed in our Intuitive name section. Each subclass
  //      member function call this one eventually...
  
	// multi-purpose flag, see code comments.
	bool TreeAddressable();       // -- tree.h:1119 M_372


	bool TypeSaturating();        // -- tree.h:1376 M_386

// -- plugin/include/tree.h:1105
public:

	//...
	bool TreeStatic(); // -- tree.h:1142

	//...
	bool TreeSideEffects(); // -- tree.h:1228

	/* These flags are available for each language front end to use internally.  */
	bool TreeLangFlag0(); // -- tree.h:1379 M_389
	bool TreeLangFlag1(); // -- tree.h:1380 M_390
	bool TreeLangFlag2(); // -- tree.h:1381 M_391
	bool TreeLangFlag3(); // -- tree.h:1382 M_392
	bool TreeLangFlag4(); // -- tree.h:1383 M_393
	bool TreeLangFlag5(); // -- tree.h:1384 M_394
	bool TreeLangFlag6(); // -- tree.h:1385 M_395


	/* Used to keep track of visited nodes in tree traversals.  This is set to
	   0 by copy_node and make_node.  */
	bool TreeVisited(); // -- tree.h:2248 M_397

public: // Direct macro to member function map


};


// -- plugin/include/tree.h:410
// struct GTY(()) tree_common {
// struct tree_base base;
// tree chain;
// tree type;
// };
class tree_common : public tree_base
{
public:
	explicit tree_common(tree node) : tree_base(node){};
public: // Direct macro to member function map
	tree TreeChain() const; // -- tree.h:(862,938), M_412
	tree TreeType() const;  // -- tree.h:(870,939), M_413
public: // Intuitive name for macro purpose
	// We may abstract CHAIN into std container interface
	// iterator... C++11's foreach for(:) ...
	// We really need it, our value is represented here!
	//tree _LinkListGetNext(void);

};



// -- [plug-inc]/double-int.h:54
//typedef struct
//{
//  unsigned HOST_WIDE_INT low;
//  HOST_WIDE_INT high;
//} double_int;
//
// -- tree.h:1409
// struct GTY(()) tree_int_cst {
//   struct tree_common common;
//   double_int int_cst;
// };
class tree_int_cst : public tree_common
{
public: // Direct macro to member function map
	double_int TreeIntCst();                // -- tree.h:1393, M_1411
	unsigned HOST_WIDE_INT TreeIntCstLow(); // -- tree.h:1394, P_1411
	HOST_WIDE_INT TreeIntCstHigh();         // -- tree.h:1395, P_1411
	// tree.h:1397, 1402  ?? not belong this class, but close related.
	// bool IntCstLt (const ) ???
public: // Intuitive name for macro purpose
	// bool operator < (const tree_int_cst&);    // =~= tree.h: WRONG.... both signed and unsigned...conflict
};

// -- tree.h:1422
//struct GTY(()) tree_real_cst {
//  struct tree_common common;
//  struct real_value * real_cst_ptr;
//};
class tree_real_cst : public tree_common
{
public: // Direct macro to member function map
	struct real_value * TreeRealCstPtr();  // -- tree.h:1419, M_1424
	struct real_value TreeRealCst();       // -- tree.h:1420, P_1424
public: // Intuitive name for macro purpose

};

// -- tree.h:1434
//struct GTY(()) tree_fixed_cst {
//  struct tree_common common;
//  struct fixed_value * fixed_cst_ptr;
//};
class tree_fixed_cst : public tree_common
{
public: // Direct macro to member function map
	struct fixed_value * TreeFixedCstPtr();  // -- tree.h:1430, M_1436
	struct fixed_value TreeFixedCst();       // -- tree.h:1432, P_1436 //Ray: Type safe. Cost? Compiler is smart
public: // Intuitive name for macro purpose

};


// -- tree.h:1444
// struct GTY(()) tree_string {
//   struct tree_common common;
//   int length;
//   char str[1];
// };
class tree_string : public tree_common
{
public: // Direct macro to member function map
	int TreeStringLength();            // -- tree.h:1440, M_1446
	const char * TreeStringPointer();  // -- tree.h:1441, M_1447
public: // Intuitive name for macro purpose
	//Ray:
	// Do NOT provide std::string conversion here, useless, boring, maybe stupid...
	// We do not want to depend std library here, unnecessary.
	// Anyone wants it can convert by themself.
};


// -- tree.h:1454
//struct GTY(()) tree_complex {
//  struct tree_common common;
//  tree real;
//  tree imag;
//};
class tree_complex : public tree_common
{
public: // Direct macro to member function map
	tree TreeRealpart(void);  // -- tree.h:1451, M_1456
	tree TreeImagpart(void);  // -- tree.h:1452, M_1457
public: // Intuitive name for macro purpose

};


//Ray:
// tree_vector != tree_vec [plug-inc]/tree.h:1508
//
// tree_vector is a tree representing a language vector, which is also a tree.
// tree_vec    is a tree representing a vector for tree, which is a real vector (C array)
//
// -- tree.h:1463
//struct GTY(()) tree_vector {
//  struct tree_common common;
//  tree elements;
//};
class tree_vector : public tree_common
{
public: // Direct macro to member function map
	tree TreeVectorCstElts(void);    // -- tree.h:1461, M_1465  ???

public: // Intuitive name for macro purpose

};


/*
 * gccint-sec-11.2.1 Identifiers
An IDENTIFIER_NODE represents a slightly more general concept that the standard C or
C++ concept of identifier. In particular, anIDENTIFIER_NODEmay contain a ‘$’, or other
extraordinary characters.
There are never two distinct IDENTIFIER_NODEs representing the same identifier. There-
fore, you may use pointer equality to compare IDENTIFIER_NODEs, rather than using a
routine like strcmp. Use get_identifier to obtain the unique IDENTIFIER_NODE for a
supplied string.
*/

// -- [plug-inc]/symtab.h:32
//struct GTY(()) ht_identifier {
//  const unsigned char *str;
//  unsigned int len;
//  unsigned int hash_value;
//};
//
// -- tree.h:1486
// struct GTY(()) tree_identifier {
//   struct tree_common common;
//   struct ht_identifier id;        // -- [plug-inc]/symtab.h:32  == [gcc-src]/libcpp/include/symtab.h
// };
class tree_identifier : public tree_common
{
public:
	explicit tree_identifier(/*const_*/ tree node) : tree_common(node) {};
public: // Direct macro to member function map
	unsigned int IdentifierLength(void);           // -- tree.h:1472, P_1488
	const unsigned char * IdentifierPointer(void);  // -- tree.h:1474, P_1488  M_symtab.h:33
	unsigned int HashValue(void);                  // -- tree.h:1476, P_1488
public: // macros used to convert between data types
	// -- tree.h:1479
	/* Translate a hash table identifier pointer to a tree_identifier
	   pointer, and vice versa.  */
	static tree HtIdentToGccIdent(struct ht_identifier *);   // -- tree.h:1482 type convertor
	static struct ht_identifier * GccIdentToHtIdent(tree);   // -- tree.h:1484 type convertor
public:
	bool IdentifierTransparentAlias(); // -- tree.h:1372 ??
public: // Intuitive name for macro purpose
	static tree_identifier _FromHashtableIdentPtr(struct ht_identifier *); // =~= HtIdentToGccIdent
	struct ht_identifier * _ToHashtableIdentPtr(void); // =~= GccIdentToHtIdent
};


// -- tree.h:1495
//struct GTY(()) tree_list {
//  struct tree_common common;
//  tree purpose;
//  tree value;
//};
class tree_list : public tree_common //Ray: tree_list is not a container ???
{
public: // Direct macro to member function map
	tree TreePurpose(void);  // -- tree.h:1492, M_1497
	tree TreeValue(void);    // -- tree.h:1493, M_1498
public: // Intuitive name for macro purpose

};


// -- tree.h:1508
// struct GTY(()) tree_vec {
//   struct tree_common common;
//   int length;
//   tree GTY ((length ("TREE_VEC_LENGTH ((tree)&%h)"))) a[1];
// };
class tree_vec : public tree_common
{
public: // Direct macro to member function map
	int TreeVecLength(void);    // -- tree.h:1502, M_1510
	//??TreeVecEnd(void); // -- tree.h:1503, P_ 1511
	tree TreeVecElt(int index); // -- tree.h:1502, C_ ??
public: // Intuitive name for macro purpose
};


// -- tree.h:1567
//struct GTY(()) tree_constructor {
//  struct tree_common common;
//  VEC(constructor_elt,gc) *elts;
//};
class tree_constructor : public tree_common
{
public: // Direct macro to member function map

public: // Intuitive name for macro purpose

};
//Ray: We really need a container wrapper for VEC, etc.
//     keep it with standard (limited) 'std::' container semantics.

//Ray:
// It's an abstract class. For various xxx_EXPR tree.def classes.
// tree.h:1572- has lots macro for fields and accessors
// grouping them to subclass according to tree.def
//
// -- tree.h:1857
//struct GTY(()) tree_exp {
//  struct tree_common common;
//  location_t locus;
//  tree block;
//  tree GTY ((special ("tree_exp"),
//	     desc ("TREE_CODE ((tree) &%0)")))
//    operands[1];
//};
class tree_exp : public tree_common
{
// type checking services, for contract programming
// it is different from member access macros
public:
	static tree ExprCheck(tree);  // -- tree.h:796

public: // Direct macro to member function map
	location_t SetExprLocation(location_t value);  // -- tree.h:1602, Ms_1859
	bool ExprHasLocation();          // -- tree.h:1603, P_(1859, UNKNOWN_LOCATION)
	//??ExprFilename(void);  // -- tree.h:1605 P_
	//??ExprLineno(void);    // -- tree.h:1606 P_

	/* Compute the number of operands in an expression node NODE.  For
	   tcc_vl_exp nodes like CALL_EXPRs, this is stored in the node itself,
	   otherwise it is looked up from the node's code.  */
	/*c_virtual*/ int TreeOperandLength(); // -- tree.h:1580==5607 P_( )
	tree TreeOperand(int index); // -- tree.h:1581==835 P_593

public: // Intuitive name for macro purpose

};

// -- tree.h:1923
//struct GTY(()) tree_ssa_name {
//  struct tree_common common;
//
//  /* _DECL wrapped by this SSA name.  */
//  tree var;
class tree_ssa_name : public tree_common
{
public: // Direct macro to member function map
	tree SsaNameVar(void);       // -- tree.h:1870, M_1927
	gimple SsaNameDefStmt(void); // -- tree.h:1873, M_1930
	unsigned int SsaNameVersion(void); // -- tree.h:1877, M_1933

	// typedef struct GTY(()) ssa_use_operand_d {  // -- tree.h:1908
	struct ssa_use_operand_d SsaNameImmUseNode(void); // -- tree.h:1921, M_1939
public: // Intuitive name for macro purpose

};

//Ray: Since we have M_ in comment, why put it to function declare?
//    Remark, we modify this file from bottom to up

// -- tree.h:1942
//struct GTY(()) phi_arg_d {
//  /* imm_use MUST be the first element in struct because we do some
//     pointer arithmetic with it.  See phi_arg_index_from_use.  */
//  struct ssa_use_operand_d imm_use;
//
//Ray: What's this?

// -- tree.h:1963
//struct GTY(()) tree_omp_clause {
//  struct tree_common common;
//  location_t locus;
//  enum omp_clause_code code;
class tree_omp_clause : public tree_common
{
public: // Direct macro to member function map

public: // Intuitive name for macro purpose

};

// -- tree.h:2034
//struct GTY(()) tree_block {
//  struct tree_common common;
//
//  unsigned abstract_flag : 1;
//  unsigned block_num : 31;
class tree_block : public tree_common
{
public: // Direct macro to member function map
  tree BlockVars(void);                  // -- tree.h:1983, M_2042
  tree BlockSubblocks(void);             // -- tree.h:1990, M_2045
  tree BlockSupercontext(void);          // -- tree.h:1991, M_2046
  tree BlockAbstractOrigin(void);        // -- tree.h:1995, M_2047
  bool BlockAbstract(void);              // -- tree.h:1996, M_2037
  Bf(31, unsigned) BlockNumber(void);     // -- tree.h:2001, M_2038
  tree BlockFragmentOrigin(void);        // -- tree.h:2025, M_2048
  tree BlockFragmentChain(void);         // -- tree.h:2026, M_2049
  location_t BlockSourceLocation(void);  // -- tree.h:2032, M_2040
public: // Intuitive name for macro purpose

};



// -- tree.h:2332
//struct GTY(()) tree_type {
//  struct tree_common common;
//  tree values;
//  tree size;
//  //...
class tree_type : public tree_common
{
public:
	unsigned int TypeHash();  // -- tree.h:970==2063 P_2338
public: // Direct macro to member function map
	unsigned int TypeUid();      // -- tree.h:2063 M_2338
	tree TypeSize();             // -- tree.h:2064 M_2335
	tree TypeSizeUnit();         // -- tree.h:2065 M_2336
	tree TypeCachedValues();     // -- tree.h:2066 M_2334
	tree TypePointerTo();        // -- tree.h:2075 M_2360
	tree TypeReferenceTo();      // -- tree.h:2076 M_2361
	Bf(10, unsigned int) TypePrecision(); // -- tree.h:2340 M_2340
	tree TypeName();         // -- tree.h:2082 M_2367
	tree TypeNextVariant();  // -- tree.h:2083 M_2370
	tree TypeMainVariant();  // -- tree.h:2084 M_2371
	tree TypeContext();      // -- tree.h:2085 M_2373
	tree TypeMaxval();       // -- tree.h:2086 M_2369
	tree TypeMinval();       // -- tree.h:2087 M_2368
	Bf_enum(8, machine_mode, unsigned) TypeMode();  // -- tree.h:2091 , M_2347
    Bf_enum(8, machine_mode, unsigned) SetTypeMode( Bf_enum(8, machine_mode, unsigned) ); // -- tree.h:2094  , Ms_2347
	tree TypeCanonical();        // -- tree.h:2113, M_2374
	bool TypeStructuralEqualityP();   // -- tree.h:2120 P_(2113, 2374)
	bool SetTypeStructuralEquality(); // -- tree.h:2123 Ps_(2113, 2374)
	struct lang_type * TypeLangSpecific();  // -- tree.h:2125, M_2376


	alias_set_type TypeAliasSet();    // -- tree.h:2141 M_2359
	bool TypeAliasSetKnownP();   // -- tree.h:2145 P_2359
	tree TypeAttributes();    // -- tree.h:2149, M_2337
	unsigned int TypeAlign(); // -- tree.h:2153, M_2358
	bool TypeUserAlign();     // -- tree.h:2157 M_(399 tree_base)
	int TypeAlignUnit();      // -- tree.h:2160 P_(2153, defaults.h:423)

	// -- tree.h:2162
	/* If your language allows you to declare types, and you want debug info
	   for them, then you need to generate corresponding TYPE_DECL nodes.
	   These "stub" TYPE_DECL nodes have no name, and simply point at the
	   type node.  You then set the TYPE_STUB_DECL field of the type node
	   to point back at the TYPE_DECL node.  This allows the debug routines
	   to know that the two nodes represent the same type, so that we only
	   get one debug info record for them.  */
	tree TypeStubDecl();  // -- tree.h:2169 P_(862, 412 tree_common.chain)

	// -- tree.h:2171
	/* In a RECORD_TYPE, UNION_TYPE or QUAL_UNION_TYPE, it means the type
	   has BLKmode only because it lacks the alignment requirement for
	   its size.  */
	bool TypeNoForceBlk();   // -- tree.h:2174, M_2341

	/* Nonzero in a type considered volatile as a whole.  */
	bool TypeVolatile();   // -- tree.h:2188 M_(373 tree_base)

	/* Means this type is const-qualified.  */
	bool TypeReadonly();   // -- tree.h:2101 M_(374 tree_base)

	/* If nonzero, this type is `restrict'-qualified, in the C sense of
	   the term.  */
	bool TypeRestrict();     // -- tree.h:2195 M_(2344 tree_type)

	/* If nonzero, type's name shouldn't be emitted into debug info.  */
	bool TypeNameless();  // -- tree.h:2198 M_(400 tree_base)

	/* The address space the type is in.  */
	Bf(8, unsigned) TypeAddrSpace(); // -- tree.h:2201 M_(407 tree_base)

	//Ray: They are different from TREE_LANG_FLAG_xxx (tree_base)
	/* These flags are available for each language front end to use internally.  */
	bool TypeLangFlag0();    // -- tree.h:2238, M_2350
	bool TypeLangFlag1();    // -- tree.h:2239, M_2351
	bool TypeLangFlag2();    // -- tree.h:2240, M_2352
	bool TypeLangFlag4();    // -- tree.h:2241, M_2354
	bool TypeLangFlag5();    // -- tree.h:2242, M_2355
	bool TypeLangFlag3();    // -- tree.h:2243, M_2353
	bool TypeLangFlag6();    // -- tree.h:2244, M_2356


	/* If set in an ARRAY_TYPE, indicates a string type (for languages
	   that distinguish string from array of char).
	   If set in a INTEGER_TYPE, indicates a character type.  */
	bool TypeStringFlag();   // -- tree.h:2253, M_2349

	/* Indicates that objects of this type must be initialized by calling a
	   function when they are created.  */
	bool TypeNeedsConstructing(); // -- tree.h:2277, M_2342

	/* Indicated that objects of this type should be laid out in as
	   compact a way as possible.  */
	bool TypePacked(); // -- tree.h:2295 M_(398 tree_base)

private: //???
	/* Used by type_contains_placeholder_p to avoid recomputation.
	   Values are: 0 (unknown), 1 (false), 2 (true).  Never access
	   this field directly.  */
    Bf(2, unsigned) TypeContainsPlaceholderInternal(); // -- tree.h:2300, M_2345
public:

    // Following three are defined within one union with different type
    /* Symtab field as an integer.  Used by stabs generator in dbxout.c to
       hold the type's number in the generated stabs.  */
    int TypeSymtabAddress();             // -- tree.h:2312, M_2366.2363

    /* Symtab field as a string.  Used by COFF generator in sdbout.c to
       hold struct/union type tag names.  */
    const char * TypeSymtabPointer();    // -- tree.h:2316, M_2366.2364

    /* Symtab field as a pointer to a DWARF DIE.  Used by DWARF generator
       in dwarf2out.c to point to the DIE generated for the type.  */
    struct die_struct * TypeSymtabDie(); // -- tree.h:2320, M_2366.2365
public:

    /* Nonzero for a type which is at file scope.  */
    bool TypeFileScopeP();  // -- tree.h:2731 P_2085

public: // Intuitive name for macro purpose
    const char * _GetSymtabAsAString();
    int _GetSymtabAsAnInteger();
    struct die_struct * _GetSymtabAsAPointToADwarfDie();
};


// -- tree.h:2379
/* Define accessor macros for information about type inheritance
   and basetypes.

   A "basetype" means a particular usage of a data type for inheritance
   in another type.  Each such basetype usage has its own "binfo"
   object to describe it.  The binfo object is a TREE_VEC node.

   Inheritance is represented by the binfo nodes allocated for a
   given type.  For example, given types C and D, such that D is
   inherited by C, 3 binfo nodes will be allocated: one for describing
   the binfo properties of C, similarly one for D, and one for
   describing the binfo properties of D as a base type for C.
   Thus, given a pointer to class C, one can get a pointer to the binfo
   of D acting as a basetype for C by looking at C's binfo's basetypes.  */
// -- tree.h:2482
//struct GTY (()) tree_binfo {
//  struct tree_common common;
//
//  tree offset;
//  //...
class tree_binfo : public tree_common
{
public: // Direct macro to member function map
	/* Nonzero means that the derivation chain is via a `virtual' declaration.  */
	bool BinfoVirtualP();    // -- tree.h:2397 M_(381 tree_base)

	/* Flags for language dependent use.  */
	bool BinfoMarked();   // -- tree.h:2400==1379 M_(389 tree_base)
	bool BinfoFlag1();    // -- tree.h:2401
	bool BinfoFlag2();    // -- tree.h:2402
	bool BinfoFlag3();    // -- tree.h:2403
	bool BinfoFlag4();    // -- tree.h:2404
	bool BinfoFlag5();    // -- tree.h:2405
	bool BinfoFlag6();    // -- tree.h:2406

	/* The actual data type node being inherited in this basetype.  */
	tree BinfoType();     // -- tree.h:2409

	/* The offset where this basetype appears in its containing type.
	   BINFO_OFFSET slot holds the offset (in bytes)
	   from the base of the complete object to the base of the part of the
	   object that is allocated on behalf of this `type'.
	   This is always 0 except when there is multiple inheritance.  */
	tree BinfoOffset();    // -- tree.h:2417 M_2485
	bool BinfoOffsetZerop(); // -- tree.h:2418 P_(4647 defined in [gcc-src]/gcc/tree.c:1708)

	/* The virtual function table belonging to this basetype.  Virtual
	   function tables provide a mechanism for run-time method dispatching.
	   The entries of a virtual function table are language-dependent.  */
	tree BinfoVtable();    // -- tree.h:2424 M_2486

	/* The virtual functions in the virtual function table.  This is
	   a TREE_LIST that is used as an initial approximation for building
	   a virtual function table for this basetype.  */
	tree BinfoVirtuals();  // -- tree.h:2429 M_2487

public: // VEC access ....
	//Ray: TODO This section is not complete, it needs heavily refector/refine!

	/* A vector of binfos for the direct basetypes inherited by this
	   basetype.

	   If this basetype describes type D as inherited in C, and if the
	   basetypes of D are E and F, then this vector contains binfos for
	   inheritance of E and F by C.  */
	Vec_ptr(tree,gc) BinfoBaseBinfos();  // -- tree.h:2437 M_2495

	/* The number of basetypes for NODE.  */
	unsigned BinfoNBaseBinfos(); // -- tree.h:2440==vec.h:150  P_2495

	/* Accessor macro to get to the Nth base binfo of this binfo.  */
	tree BinfoBaseBinfo(unsigned ix); // -- tree.h:(2443 P_2495) ==VEC_index vec.h:177.172

	bool BinfoBaseIterate(unsigned ix, tree& ptr);  // -- tree.h:2445==vec.h:191.181  P_2495
	tree* BinfoBaseAppend(tree obj); // -- tree.h:(2447 P_2495) == VEC_quick_push vec.h:310.302

public:

	/* For a BINFO record describing a virtual base class, i.e., one where
	   TREE_VIA_VIRTUAL is set, this field assists in locating the virtual
	   base.  The actual contents are language-dependent.  In the C++
	   front-end this field is an INTEGER_CST giving an offset into the
	   vtable where the offset to the virtual base can be found.  */
	tree BinfoVptrField();  // -- tree.h:2455 M_2488

public: // VEC access .... TODO: heavily refine
	/* Indicates the accesses this binfo has to its bases. The values are
	   access_public_node, access_protected_node or access_private_node.
	   If this array is not present, public access is implied.  */
	Vec_ptr(tree, gc) BinfoBaseAccesses(); // --tree.h:2460 M_2489
	tree BinfoBaseAccess(unsigned ix); // -- tree.h:(2462 P_2489) == VEC_index
	tree* BinfoBaseAccessAppend(tree obj); // -- tree.h:(2464 P_2489) == VEC_quick_push

public:
	/* The index in the VTT where this subobject's sub-VTT can be found.
	   NULL_TREE if there is no sub-VTT.  */
	tree BinfoSubvttIndex();  // -- tree.h:2469 M_2492

	/* The index in the VTT where the vptr for this subobject can be
	   found.  NULL_TREE if there is no secondary vptr in the VTT.  */
	tree BinfoVptrIndex();    // -- tree.h:2473 M_2493

	/* The BINFO_INHERITANCE_CHAIN points at the binfo for the base
	   inheriting this base for non-virtual bases. For virtual bases it
	   points either to the binfo for which this is a primary binfo, or to
	   the binfo of the most derived type.  */
	tree BinfoInheritanceChain();  // -- tree.h:2479
public: // Intuitive name for macro purpose
//	tree_type _TheActualDatatypeBeingInheriedInThisBasetype();
	// container list BinfoVirtuals
};

// -- tree.h:2579
//struct GTY(()) tree_decl_minimal {
//  struct tree_common common;
//  location_t locus;
//  unsigned int uid;
//  tree name;
//  tree context;
//};
class tree_decl_minimal : public tree_common
{
public: // Direct macro to member function map
	tree DeclChain();  // -- tree.h:2528==862 M_(412 tree_common)

	/* This is the name of the object as written by the user.
	   It is an IDENTIFIER_NODE.  */
	tree DeclName(); // -- tree.h:2532 M_2583

	/* Every ..._DECL node gets a unique number.  */
	unsigned int DeclUid(); // -- tree.h:2535 M_2582

public:
	/* These two fields describe where in the source code the declaration
	   was.  If the declaration appears in several places (as for a C
	   function that is declared first and then defined later), this
	   information should refer to the definition.  */

	// typedef source_location location_t;   -- [plug-inc]/input.h:58
	// typedef unsigned int source_location; -- [plug-inc]/line-map.h:42
	location_t DeclSourceLocation();  // -- tree.h:2558 M_2581
	DeclSourceFile();  // -- tree.h:2560 P_2581
	DeclSourceLine();  // -- tree.h:2561 P_2581
	bool DeclIsBuiltin();  // -- tree.h:2562 P_2581

public:
	/*  For FIELD_DECLs, this is the RECORD_TYPE, UNION_TYPE, or
	    QUAL_UNION_TYPE node that the field is a member of.  For VAR_DECL,
	    PARM_DECL, FUNCTION_DECL, LABEL_DECL, RESULT_DECL, and CONST_DECL
	    nodes, this points to either the FUNCTION_DECL for the containing
	    function, the RECORD_TYPE or UNION_TYPE for the containing type, or
	    NULL_TREE or a TRANSLATION_UNIT_DECL if the given decl has "file
	    scope".  */
	tree DeclContext();       // -- tree.h:2572 M_2584

public:
	/* If nonzero, decl's name shouldn't be emitted into debug info.  */
	bool DeclNameless();      // -- tree.h:2577 M_(400 tree_base)

public: // Intuitive name for macro purpose

};

// -- tree.h:2747
//struct GTY(()) tree_decl_common {
//  struct tree_decl_minimal common;
//  tree size;
//  //...
class tree_decl_common : public tree_decl_minimal
{
public: // Direct macro to member function map

	//Ray:
	// Notice, macro define in tree.h:2544
	// -1u    -- it's unsigned int
	//
	/* Every ..._DECL node gets a unique number that stays the same even
	   when the decl is copied by the inliner once it is set.  */
	unsigned int DeclPtUid();  // -- tree.h:2543 P_(2807, 2582 tree_decl_minimal)

	/* Initialize the ..._DECL node pt-uid to the decls uid.  */
	unsigned int SetDeclPtUid(unsigned int uid); // -- tree.h:2547 Ms_2807

	/* Whether the ..._DECL node pt-uid has been initialized and thus needs to
	   be preserved when copyin the decl.  */
	bool DeclPtUidSetP();

	/* For any sort of a ..._DECL node, this points to the original (abstract)
	   decl node which this decl is an inlined/cloned instance of, or else it
	   is NULL indicating that this decl is not an instance of some other decl.

	   The C front-end also uses this in a nested declaration of an inline
	   function, to point back to the definition.  */
	tree DeclAbstractOrigin();  // -- tree.h:2594 M_2812

	/* Like DECL_ABSTRACT_ORIGIN, but returns NODE if there's no abstract
	   origin.  This is useful when setting the DECL_ABSTRACT_ORIGIN.  */
	tree DeclOrigin();  // -- tree.h:2599 P_2812

	/* Nonzero for any sort of ..._DECL node means this decl node represents an
	   inline instance of some original (abstract) decl from an inline function;
	   suppress any warnings about shadowing some other variable.  FUNCTION_DECL
	   nodes can also have their abstract origin set to themselves.  */
	bool DeclFromInline(); // -- tree.h:2606 P_(2594 2812)

	/* In a DECL this is the field where attributes are stored.  */
	tree DeclAttributes();  // -- tree.h:2611 M_2811
public:

	/* For a FUNCTION_DECL, holds the tree of BINDINGs.
	   For a TRANSLATION_UNIT_DECL, holds the namespace's BLOCK.
	   For a VAR_DECL, holds the initial value.
	   For a PARM_DECL, used for DECL_ARG_TYPE--default
	   values for parameters are encoded in the type of the function,
	   not in the PARM_DECL slot.
	   For a FIELD_DECL, this is used for enumeration values and the C
	   frontend uses it for temporarily storing bitwidth of bitfields.

	   ??? Need to figure out some way to check this isn't a PARM_DECL.  */
	tree DeclInitial();  // -- tree.h:2624 M_2810

public:

	/* Holds the size of the datum, in bits, as a tree expression.
	   Need not be constant.  */
	tree DeclSize();  // -- tree.h:2628 M_2749

	/* Likewise for the size in bytes.  */
	tree DeclSizeUnit();  // -- tree.h:2630 M_2809

	/* Holds the alignment required for the datum, in bits.  */
	unsigned int DeclAlign(); // -- tree.h:2632 M_2804

	/* The alignment of NODE, in bytes.  */
	unsigned int DeclAlignUnit(); // -- tree.h:2634 P_(2632 2804)

	/* Set if the alignment of this DECL has been set by the user, for
	   example with an 'aligned' attribute.  */
	bool DeclUserAlign();  // -- tree.h:2637 M_(399 tree_base)

	/* Holds the machine mode corresponding to the declaration of a variable or
	   field.  Always equal to TYPE_MODE (TREE_TYPE (decl)) except for a
	   FIELD_DECL.  */
	Bf_enum(8, machine_mode, unsigned) DeclMode(); // tree.h:2642 M_2751

	bool DeclDebugExprIsFrom();  // -- tree.h:2650 M_2759

	/* Nonzero for a given ..._DECL node means that the name of this node should
	   be ignored for symbolic debug purposes.  For a TYPE_DECL, this means that
	   the associated type should be ignored.  For a FUNCTION_DECL, the body of
	   the function should also be ignored.  */
	bool DeclIgnoredP(); // -- tree.h:2660 M_2755

	/* Nonzero for a given ..._DECL node means that this node represents an
	   "abstract instance" of the given declaration (e.g. in the original
	   declaration of an inline function).  When generating symbolic debugging
	   information, we mustn't try to generate any address information for nodes
	   marked as "abstract instances" because we don't actually generate
	   any code or allocate any data space for such instances.  */
	bool DeclAbstract();  // -- tree.h:2669 M_2756

	/* Language-specific decl information.  */
	struct lang_decl * DeclLangSpecific(); // -- tree.h:2673 M_2815

	/* In a VAR_DECL or FUNCTION_DECL, nonzero means external reference:
	   do not allocate storage, and refer to a definition elsewhere.  Note that
	   this does not necessarily imply the entity represented by NODE
	   has no program source-level definition in this translation unit.  For
	   example, for a FUNCTION_DECL, DECL_SAVED_TREE may be non-NULL and
	   DECL_EXTERNAL may be true simultaneously; that can be the case for
	   a C99 "extern inline" function.  */
	bool DeclExternal();  // -- tree.h:2683 M_2777

	/* Nonzero in a ..._DECL means this variable is ref'd from a nested function.
	   For VAR_DECL nodes, PARM_DECL nodes, and FUNCTION_DECL nodes.

	   For LABEL_DECL nodes, nonzero if nonlocal gotos to the label are permitted.

	   Also set in some languages for variables, etc., outside the normal
	   lexical scope, such as class instance variables.  */
	bool DeclNonlocal();  // -- tree.h:2692 M_2753

	/* Used in VAR_DECLs to indicate that the variable is a vtable.
	   Used in FIELD_DECLs for vtable pointers.
	   Used in FUNCTION_DECLs to indicate that the function is virtual.  */
	bool DeclVirtualP();  // -- tree.h:2698 M_2754

	/* Used to indicate that this DECL represents a compiler-generated entity.  */
	bool DeclArtificial(); // -- tree.h:2702 M_2757

	/* Additional flags for language-specific uses.  */
	bool DeclLangFlag0();  // -- tree.h:2706 M_2761
	bool DeclLangFlag1();  // -- tree.h:2708 M_2762
	bool DeclLangFlag2();  // -- tree.h:2710 M_2763
	bool DeclLangFlag3();  // -- tree.h:2712 M_2764
	bool DeclLangFlag4();  // -- tree.h:2714 M_2765
	bool DeclLangFlag5();  // -- tree.h:2716 M_2766
	bool DeclLangFlag6();  // -- tree.h:2718 M_2767
	bool DeclLangFlag7();  // -- tree.h:2720 M_2768
	bool DeclLangFlag8();  // -- tree.h:2722 M_2769

	/* Nonzero for a decl which is at file scope.  */
	bool DeclFileScopeP(); // -- tree.h:2729 P_(2572 tree_decl_minimal)

	/* Nonzero for a decl that is decorated using attribute used.
	   This indicates to compiler tools that this decl needs to be preserved.  */
	bool DeclPreserveP();  // -- tree.h:2735 M_2758

	/* For function local variables of COMPLEX and VECTOR types,
	   indicates that the variable is not aliased, and that all
	   modifications to the variable have been adjusted so that
	   they are killing assignments.  Thus the variable may now
	   be treated as a GIMPLE register, and use real instead of
	   virtual ops in SSA form.  */
	bool DeclGimpleRegP();  // -- tree.h:2744 M_2784
public:

public: // Intuitive name for macro purpose

};

// -- tree.h:2863
//struct GTY(()) tree_decl_with_rtl {
//  struct tree_decl_common common;
//  rtx rtl;
//};
class tree_decl_with_rtl : public tree_decl_common
{
public: // Direct macro to member function map
	tree DeclValueExpr();  // -- tree.h:2828 P_2818
	void SetDeclValueExpr(tree val); // -- tree.h:2830 P_2819

	/* Holds the RTL expression for the value of a variable or function.
	   This value can be evaluated lazily for functions, variables with
	   static storage duration, and labels.  */
	rtx DeclRtl();  // -- tree.h:2836 M_2865
	SetDeclRtl(rtx v); // -- tree.h:2842 P_
public: // Intuitive name for macro purpose

};

// -- tree.h:2931
//struct GTY(()) tree_field_decl {
//  struct tree_decl_common common;
//
//  tree offset;
//  tree bit_field_type;
//  tree qualifier;
//  tree bit_offset;
//  tree fcontext;
//};
class tree_field_decl : public tree_decl_common
{
public: // macro to member function map
};

// -- tree.h:2957
//struct GTY(()) tree_label_decl {
//  struct tree_decl_with_rtl common;
//  int label_decl_uid;
//  int eh_landing_pad_nr;
//};
class tree_label_decl : public tree_decl_with_rtl  //requires LABEL_DECL_CHECK
{
public: // macro to member function map
	int LabelDeclUid();    // -- tree.h:2944
	int EhLandingPadNr();  // -- tree.h:2949
};


// -- tree.h:2964
//struct GTY(()) tree_result_decl {
//  struct tree_decl_with_rtl common;
//  struct var_ann_d *ann;
//};
class tree_result_decl : public tree_decl_with_rtl
{
public: // macro to member function map
};

// -- tree.h:2969
//struct GTY(()) tree_const_decl {
//  struct tree_decl_with_rtl common;
//};
class tree_const_decl : public tree_decl_with_rtl
{
public: // macro to member function map
};

// -- tree.h:2982
//struct GTY(()) tree_parm_decl {
//  struct tree_decl_with_rtl common;
//  rtx incoming_rtl;
//  struct var_ann_d *ann;
//};
class tree_parm_decl : public tree_decl_with_rtl
{
public: // macro to member function map

};


// -- tree.h:3121
//struct GTY(()) tree_decl_with_vis {
// struct tree_decl_with_rtl common;
// tree assembler_name;
// tree section_name;
// tree comdat_group;
// //...
class tree_decl_with_vis : public tree_decl_with_rtl
{
public: // macro to member function map

	/* Nonzero for a given ..._DECL node means that no warnings should be
	   generated just because this node is unused.  */
	bool DeclInSystemHeader(); // -- tree.h:2991
	/* Used to indicate that the linkage status of this DECL is not yet known,
	   so it should not be output now.  */
	bool DeclDeferOutput(); // -- tree.h:2996
	/* In a VAR_DECL that's static,
	   nonzero if the space is in the text section.  */
	bool DeclInTextSection(); // -- tree.h:3001
	/* In a VAR_DECL that's static,
	   nonzero if it belongs to the global constant pool.  */
	bool DeclInConstantPool(); // -- tree.h:3006
	/* Nonzero for a given ..._DECL node means that this node should be
	   put in .common, if possible.  If a DECL_INITIAL is given, and it
	   is not error_mark_node, then the decl cannot be put in .common.  */
	bool DeclCommon();      // -- tree.h:3012
	/* Used to indicate that this DECL has weak linkage.  */
	bool DeclWeak();  // -- tree.h:3021
	/* Used to indicate that the DECL is a dllimport.  */
	bool DeclDllimportP(); // -- tree.h:3024
	/* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME.
	   This is true of all DECL nodes except FIELD_DECL.  */
	bool HasDeclAssemblerNameP(); // -- tree.h:3053
};

// -- tree.h:3205
//struct GTY(()) tree_var_decl {
//  struct tree_decl_with_vis common;
//  struct var_ann_d *ann;
//};
class tree_var_decl : public tree_decl_with_vis
{

};

// -- tree.h:3227
//struct GTY(())
// tree_decl_non_common {
//  struct tree_decl_with_vis common;
//  /* C++ uses this in namespaces.  */
//  tree saved_tree;
//  /* C++ uses this in templates.  */
//  tree arguments;
//  /* Almost all FE's use this.  */
//  tree result;
//  /* C++ uses this in namespaces.  */
//  tree vindex;
//};
class tree_decl_non_common : public tree_decl_with_vis
{

public: // macro to member function map
	tree DeclResultFld(); // -- tree.h:3213
	tree DeclVindex();    // -- tree.h:3224
};


// -- tree.h:3369
/* FUNCTION_DECL inherits from DECL_NON_COMMON because of the use of the
   arguments/result/saved_tree fields by front ends.   It was either inherit
   FUNCTION_DECL from non_common, or inherit non_common from FUNCTION_DECL,
   which seemed a bit strange.  */
//struct GTY(()) tree_function_decl {
//  struct tree_decl_non_common common;
//
//  struct function *f;
//  //...
class tree_function_decl : public tree_decl_non_common
{
public: // macro to member function map

	/* For FUNCTION_DECL, if it is built-in, this identifies which built-in
	   operation it is.  Note, however, that this field is overloaded, with
	   DECL_BUILT_IN_CLASS as the discriminant, so the latter must always be
	   checked before any access to the former.  */
	//Ray: the latter == decl_common.DECL_DEBUG_EXPR_IS_FROM()
	Bf_enum(11, built_in_function, int) DeclFunctionCode();  // tree.h:2648 M_3385

	/* The personality function. Used for stack unwinding. */
	tree DeclFunctionPersonality();  // tree.h:2653 M_3375
};

// -- tree.h:3417
/* TRANSLATION_UNIT_DECL inherits from DECL_MINIMAL.  */
//struct GTY(()) tree_translation_unit_decl {
//  struct tree_decl_common common;
//  /* Source language of this translation unit.  Used for DWARF output.  */
//  const char * GTY((skip(""))) language;
//  /* TODO: Non-optimization used to build this translation unit.  */
//  /* TODO: Root of a partial DWARF tree for global types and decls.  */
//};
class tree_translation_unit_decl : public tree_decl_common
{

public: // macro to member function map
	const char * TranslationUnitLanguage(); // -- tree.h:??
};


// -- tree.h:3443
//struct GTY(()) tree_type_decl {
//  struct tree_decl_non_common common;
//
//};
class tree_type_decl : public tree_decl_non_common
{

};

// -- tree.h:3466
//struct GTY(()) tree_statement_list
// {
//  struct tree_common common;
//  struct tree_statement_list_node *head;
//  struct tree_statement_list_node *tail;
//};
class tree_statement_list : public tree_common
{

};

// -- tree.h:3476
/* Optimization options used by a function.  */
//struct GTY(()) tree_optimization_option {
//  struct tree_common common;
//
//  /* The optimization options used by the user.  */
//  struct cl_optimization opts;
//};
class tree_optimization_option : public tree_common
{

};

// -- tree.h:3491
/* Target options used by a function.  */
//struct GTY(()) tree_target_option {
//  struct tree_common common;
//
//  /* The optimization options used by the user.  */
//  struct cl_target_option opts;
//};
class tree_target_option : public tree_common
{
public:

};


}// end namespace plugin_cxx

//#pragma GCC poison tree


#endif /* CXX_TREE_HXX_ */
