/*
 * cxx-tree.h
 *
 *  Created on: Mar 14, 2012
 *      Author: ray
 */

#ifndef CXX_TREE_H_
#define CXX_TREE_H_

#include <stddef.h>

// Code reference comment convention
//
// -- [dir-prefix] filename : linenumber
//
// 1. When no dir-prefix is given, default directory prefix is [plug-inc]
// 2. When refer to gcc source, we should alway use [gcc-src] prefix
// 3. Valid dir-prefix are:
//    [plug-inc]     plugin include directory for plugin deverlopers
//    [gcc-src]      gcc source code root directory
//
// For example:
// -- tree.h:367                      example 1
// -- [plug-inc]/tree.h:367           example 2
// -- [gcc-src]/tree.c:8624           example 3
//
//    'example 1' and 'example 2' is equal
//
//copied from plugin/include/coretypes.h
union tree_node;                            // -- tree.h:3510  -- coretypes.h:59
typedef union tree_node *tree;              // -- coretypes.h:96
typedef const union tree_node *const_tree;  // -- coretypes.h:63

//Ray:  map C tree to C++
// I guess, it can be generated by code,
// But, we map them by hand now
//
// The style of 'tree.h' is
// 1. Declaring manipulating macros first
// 2. Declaring new type (in C style Object-Orientated)
// Which is somthing like followin
// TODO: put an example of OO in C (from 'tree.h')
//
//Ray: The purpose of this file (cxx-tree.h) is to wrap these macros with
//     C++ member function call. And give a true object method to
//     access various 'tree node'.
//     Keep in mind, no more, may less...
namespace plugin_cxx
{

//identfiy it is the top/root class of a hierachy tree
#define ROOT_CLASS


// -- plugin/include/tree.h:361
/* Every kind of tree node starts with this structure,
   so all nodes have these fields.

   See the accessor macros, defined below, for documentation of the
   fields.  */
// -- plugin/include/tree.h:367
class ROOT_CLASS tree_base {
public:
	explicit tree_base(tree node):m_node(node){};

	//Ray:
	// TREE_CHECK() macro  --defined in-- plugin/include/tree.h:663
	// tree_check_failed() function --defined in-- [gcc-src]/gcc/tree.c:8624
	// internal_error() function --defined in-- [gcc-src]/gcc/diagnostic.c:832
	bool Try_TREE_CHECK();
	bool TryAattach(tree node);
public:
	/* The tree-code says what kind of node it is.
	   Codes are defined in tree.def.  */
//	enum tree_code GetTreeCode(); 		// -- tree.h:656
//	enum tree_code SetTreeCode(enum tree_code);	// -- tree.h:656

	// -- plugin/include/tree.h:974
	size_t TreeHash();

	// -- plugin/include/tree.h:993
	const_tree StripNops(const_tree);
	const_tree StripSignNops(const_tree);
	const_tree StripTypeNops(const_tree);
	const_tree StripUselessTypeConversion(const_tree);
public:
	// -- plugin/include/tree.h:1021
	bool IntegralTypeP();
	bool NonSatFixedPointTypeP();
	//...
	// -- plugin/include/tree.h:1091
	bool CompleteTypeP();
	// -- plugin/include/tree.h:1094
	bool VoidTypeP();

// -- plugin/include/tree.h:1105
public:
	bool TreeAddressable();  // -- tree.h:1119

	//...
	bool TreeStatic(); // -- tree.h:1142

	//...
	bool TreeSideEffects(); // -- tree.h:1228

	//...
	bool TreeLangFlag0(); // -- tree.h:1379
protected:
	tree m_node;
};

/*
 * gccint-sec-11.2.3 Containers
Two common container data structures can be represented directly with tree nodes. A
TREE_LIST is a singly linked list containing two trees per node. ...
Given one TREE_LIST node, the next node
is found by following the TREE_CHAIN. If the TREE_CHAINis NULL_TREE, then you have
reached the end of the list.

A TREE_VEC is a simple vector. The TREE_VEC_LENGTH is an integer (not a tree) giving the
number of nodes in the vector. The nodes themselves are accessed using the TREE_VEC_ELT
macro, which takes two arguments. The first is the TREE_VEC in question; the second is an
integer indicating which element in the vector is desired. The elements are indexed from
zero.
*/

/*
 * gccint-sec-11.2.1
All GENERIC trees have two fields in common. First,TREE_CHAINis a pointer that can be
used as a singly-linked list to other trees. The other isTREE_TYPE. Many trees store the
type of an expression or declaration in this field.
*/

// -- plugin/include/tree.h:410
// struct GTY(()) tree_common {
// struct tree_base base;
// tree chain;
// tree type;
// };
class tree_common : public tree_base
{
public:
	explicit tree_common(tree node) : tree_base(node){};
// link list access
public:
	tree LinkListGetNext(void);

};


// -- plugin/include/tree.h:1409
// struct GTY(()) tree_int_cst {
//   struct tree_common common;
//   double_int int_cst;
// };
class tree_int_cst : public tree_common
{

};

// -- plugin/include/tree.h:1422
// struct GTY(()) tree_real_cst {
//   struct tree_common common;
//   struct real_value * real_cst_ptr;
// };
class tree_real_cst : public tree_common
{

};

// -- plugin/include/tree.h:1444
// struct GTY(()) tree_string {
//   struct tree_common common;
//   int length;
//   char str[1];
// };
class tree_string : public tree_common
{
public:
	int TreeStringLength();  // -- tree.h:1440
	const char * TreeStringPointer();  // -- tree.h:1441
};


class tree_decl_minimal : public tree_common
{

};

/*
 * gccint-sec-11.2.1 Identifiers
An IDENTIFIER_NODE represents a slightly more general concept that the standard C or
C++ concept of identifier. In particular, anIDENTIFIER_NODEmay contain a ‘$’, or other
extraordinary characters.
There are never two distinct IDENTIFIER_NODEs representing the same identifier. There-
fore, you may use pointer equality to compare IDENTIFIER_NODEs, rather than using a
routine like strcmp. Use get_identifier to obtain the unique IDENTIFIER_NODE for a
supplied string.
*/


// struct GTY(()) ht_identifier		plugin/include/symtab.h:32
//
// -- plugin/include/tree.h:1486
// struct GTY(()) tree_identifier {
//   struct tree_common common;
//   struct ht_identifier id;
// };
class tree_identifier : public tree_common
{
public:
	explicit tree_identifier(/*const_*/ tree node) : tree_common(node) {};
public:
	const char * DentifierPointer();  // -- tree.h:1474
	unsigned int IdentifierLength();  // -- tree.h:1472
	unsigned int HashValue();         // -- tree.h:1476
public:
	bool IdentifierTransparentAlias(); // -- tree.h:1372
};


// -- plugin/include/tree.h:1495
//struct GTY(()) tree_list {
//  struct tree_common common;
//  tree purpose;
//  tree value;
//};
class tree_list : public tree_common
{
public:
	tree TreePurpose();  // -- tree.h:1492
	tree TreeValue();    // -- tree.h:1493
};


// -- plugin/include/tree.h:1508
// struct GTY(()) tree_vec {
//   struct tree_common common;
//   int length;
//   tree GTY ((length ("TREE_VEC_LENGTH ((tree)&%h)"))) a[1];
// };
class tree_vec : public tree_common
{
public:
	int TreeVecLength();  //  -- tree.h:1502
	tree TreeVecElt(int i); // -- tree.h:1502
};

// -- plugin/include/tree.h:2332
// struct GTY(()) tree_type {
//   struct tree_common common;
//   //..
class tree_type : public tree_common
{

};



// -- tree.h:2931
//struct GTY(()) tree_field_decl {
//  struct tree_decl_common common;
//
//  tree offset;
//  tree bit_field_type;
//  tree qualifier;
//  tree bit_offset;
//  tree fcontext;
//};
class tree_decl_common : public tree_decl_common
{

};

// -- tree.h:2954
//struct GTY(()) tree_label_decl {
//  struct tree_decl_with_rtl common;
//  int label_decl_uid;
//  int eh_landing_pad_nr;
//};
class tree_label_decl : public tree_decl_with_rtl
{
public: // macro to member function map
	int LabelDeclUid();    // -- tree.h:2944
	int EhLandingPadNr();  // -- tree.h:2949
};


// -- tree.h:2964
//struct GTY(()) tree_result_decl {
//  struct tree_decl_with_rtl common;
//  struct var_ann_d *ann;
//};
class tree_result_decl : public tree_decl_with_rtl
{
public: // macro to member function map
};

// -- tree.h:2969
//struct GTY(()) tree_const_decl {
//  struct tree_decl_with_rtl common;
//};
class tree_const_decl : public tree_decl_with_rtl
{
public: // macro to member function map
};

// -- tree.h:2982
//struct GTY(()) tree_parm_decl {
//  struct tree_decl_with_rtl common;
//  rtx incoming_rtl;
//  struct var_ann_d *ann;
//};
class tree_parm_decl : public tree_decl_with_rtl
{
public: // macro to member function map

};


// -- tree.h:3121
//struct GTY(()) tree_decl_with_vis {
// struct tree_decl_with_rtl common;
// tree assembler_name;
// tree section_name;
// tree comdat_group;
// //...
class tree_decl_with_vis : public tree_decl_with_rtl
{
public: // macro to member function map

	/* Nonzero for a given ..._DECL node means that no warnings should be
	   generated just because this node is unused.  */
	bool DeclInSystemHeader(); // -- tree.h:2991
	/* Used to indicate that the linkage status of this DECL is not yet known,
	   so it should not be output now.  */
	bool DeclDeferOutput(); // -- tree.h:2996
	/* In a VAR_DECL that's static,
	   nonzero if the space is in the text section.  */
	bool DeclInTextSection(); // -- tree.h:3001
	/* In a VAR_DECL that's static,
	   nonzero if it belongs to the global constant pool.  */
	bool DeclInConstantPool(); // -- tree.h:3006
	/* Nonzero for a given ..._DECL node means that this node should be
	   put in .common, if possible.  If a DECL_INITIAL is given, and it
	   is not error_mark_node, then the decl cannot be put in .common.  */
	bool DeclCommon();      // -- tree.h:3012
	/* Used to indicate that this DECL has weak linkage.  */
	bool DeclWeak();  // -- tree.h:3021
	/* Used to indicate that the DECL is a dllimport.  */
	bool DeclDllimportP(); // -- tree.h:3024
	/* Return true if NODE is a NODE that can contain a DECL_ASSEMBLER_NAME.
	   This is true of all DECL nodes except FIELD_DECL.  */
	bool HasDeclAssemblerNameP(); // -- tree.h:3053
};

// -- tree.h:3205
//struct GTY(()) tree_var_decl {
//  struct tree_decl_with_vis common;
//  struct var_ann_d *ann;
//};
class tree_var_decl : public tree_decl_with_vis
{

};

// -- tree.h:3227
//struct GTY(())
// tree_decl_non_common {
//  struct tree_decl_with_vis common;
//  /* C++ uses this in namespaces.  */
//  tree saved_tree;
//  /* C++ uses this in templates.  */
//  tree arguments;
//  /* Almost all FE's use this.  */
//  tree result;
//  /* C++ uses this in namespaces.  */
//  tree vindex;
//};
class tree_decl_non_common : public tree_decl_with_vis
{

public: // macro to member function map
	tree DeclResultFld(); // -- tree.h:3213
	tree DeclVindex();    // -- tree.h:3224
};


// -- tree.h:3369
/* FUNCTION_DECL inherits from DECL_NON_COMMON because of the use of the
   arguments/result/saved_tree fields by front ends.   It was either inherit
   FUNCTION_DECL from non_common, or inherit non_common from FUNCTION_DECL,
   which seemed a bit strange.  */
//struct GTY(()) tree_function_decl {
//  struct tree_decl_non_common common;
//
//  struct function *f;
//  //...
class tree_function_decl : public tree_decl_non_common
{
public: // macro to member function map

};

// -- tree.h:3417
/* TRANSLATION_UNIT_DECL inherits from DECL_MINIMAL.  */
//struct GTY(()) tree_translation_unit_decl {
//  struct tree_decl_common common;
//  /* Source language of this translation unit.  Used for DWARF output.  */
//  const char * GTY((skip(""))) language;
//  /* TODO: Non-optimization used to build this translation unit.  */
//  /* TODO: Root of a partial DWARF tree for global types and decls.  */
//};
class tree_translation_unit_decl : public tree_decl_common
{

public: // macro to member function map
	const char * TranslationUnitLanguage(); // -- tree.h:??
};


// -- tree.h:3443
//struct GTY(()) tree_type_decl {
//  struct tree_decl_non_common common;
//
//};
class tree_type_decl : public tree_decl_non_common
{

};

// -- tree.h:3466
//struct GTY(()) tree_statement_list
// {
//  struct tree_common common;
//  struct tree_statement_list_node *head;
//  struct tree_statement_list_node *tail;
//};
class tree_statement_list : public tree_common
{

};

// -- tree.h:3476
/* Optimization options used by a function.  */
//struct GTY(()) tree_optimization_option {
//  struct tree_common common;
//
//  /* The optimization options used by the user.  */
//  struct cl_optimization opts;
//};
class tree_optimization_option : public tree_common
{

};

// -- tree.h:3491
/* Target options used by a function.  */
//struct GTY(()) tree_target_option {
//  struct tree_common common;
//
//  /* The optimization options used by the user.  */
//  struct cl_target_option opts;
//};
class tree_target_option : public tree_common
{
public:

};


}// end namespace plugin_cxx

//#pragma GCC poison tree


#endif /* CXX_TREE_H_ */
